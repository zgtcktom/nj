<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: func.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: func.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
	NDArray,
	asarray,
	broadcast_shapes,
	broadcast_to,
	empty,
	ravel,
	shallow_array_equal,
} from './core.mjs';

let range = length => [...Array(length).keys()];

function _cache(builder) {
	let create = () => Object.create(null);

	let root = create();

	/**
	 *
	 * @param {object} map
	 * @param {number[]} key
	 * @param {function} valuefn
	 * @returns {NDArray}
	 */
	let get = (map, key, valuefn) => {
		return map[key] ?? (map[key] = valuefn(...key));
	};

	return (...key) => get(root, key, builder);
}

/**
 * @param {number} axis
 * @param {number} ndim
 * @returns {number}
 * @ignore
 */
export function normalize_axis_index(axis, ndim) {
	// assume non null
	let _axis = axis;
	axis = +axis;
	if (!Number.isInteger(axis)) throw new Error(`${_axis} cannot be cast to integer`);
	if (axis &lt; 0) axis += ndim;
	if (axis &lt; 0 || ndim &lt;= axis) throw `axis ${_axis} is out of bounds for array of dimension ${ndim}`;
	return axis;
}

let cached_axis_masks = {};

/**
 * @param {number|number[]|null} axis
 * @param {number} ndim
 * @param {boolean} [allow_duplicate]
 * @returns {object}
 * @ignore
 */
export function normalize_axis_mask(axis, ndim, allow_duplicate = false) {
	// assume axis : int or array of int or null
	if (axis == null) {
		return cached_axis_masks[ndim] ?? (cached_axis_masks[ndim] = Array(ndim).fill(1));
	}
	let mask = Array(ndim).fill(0);
	if (Array.isArray(axis)) {
		for (let i = 0; i &lt; axis.length; i++) {
			mask[normalize_axis_index(axis[i], ndim)] = 1;
		}
		if (!allow_duplicate) {
			let count = 0;
			for (let i = 0; i &lt; ndim; i++) count += mask[i];
			if (count != axis.length) throw `repeated axis`;
		}
	} else {
		mask[normalize_axis_index(axis, ndim)] = 1;
	}
	return mask;
}

let declaration = (variables, type = 'let') => {
	if (!Array.isArray(variables)) variables = [variables];
	return `${type} ${variables.join(', ')}`;
};
let destructuringArray = (declaration = null, variables, array) => {
	if (declaration != null) {
		return `${declaration} [${variables.join(', ')}] = ${array}`;
	}
	return `[${variables.join(', ')}] = ${array}`;
};
let destructuringObject = (declaration = null, variables, object, keys = variables) => {
	let pair = [];
	for (let i = 0; i &lt; variables.length; i++) {
		pair.push(keys[i] == variables[i] ? `${keys[i]}` : `${keys[i]}: ${variables[i]}`);
	}
	if (declaration != null) {
		// console.log(variables, keys, pair, `${declaration} {${pair.join(', ')}} = ${object}`);
		return `${declaration} {${pair.join(', ')}} = ${object}`;
	}
	return `({${pair.join(', ')}} = ${object})`;
};
let assignment = (declaration = null, variables, values) => {
	if (!Array.isArray(variables)) {
		variables = [variables];
		values = [values];
	}
	let pair = [];
	for (let i = 0; i &lt; variables.length; i++) {
		pair.push(`${variables[i]} = ${values[i]}`);
	}
	if (declaration != null) {
		return `${declaration} ${pair.join(', ')}`;
	}
	return `${pair.join(', ')}`;
};
let forLoop = (index, length, body) => {
	return `for(let ${index} = 0; ${index} &lt; ${length}; ${index}++) {${body}}`;
};
let body = (...statements) => {
	return `${statements.join('; ')}`;
};
let functionCall = (fn, ...args) => {
	return `${fn}(${args.join(', ')})`;
};
let bracketAccess = (object, expr) => {
	return `${object}[${expr}]`;
};
let dotAccess = (object, ident) => {
	return `${object}.${ident}`;
};
let group = expr => {
	return `(${expr})`;
};
let product = (...args) => {
	return `${args.map(group).join(' * ')}`;
};
let sum = (...args) => {
	return `${args.map(group).join(' + ')}`;
};
let functionReturn = expr => {
	return `return ${expr}`;
};
// let range = length => [...Array(length).keys()];

function variableNames(narg, ndim, out_dim = ndim) {
	let fn = 'fn';
	let out = 'out';
	let x = range(narg).map(i => `x${i + 1}`);

	let out_offset = `${out}_offset`;
	let x_offset = x.map(x => `${x}_offset`);

	let out_data = `${out}_data`;
	let x_data = x.map(x => `${x}_data`);

	let out_strides = range(out_dim).map(axis => `${out}_strides_${axis}`);
	let x_strides = x.map(x => range(ndim).map(axis => `${x}_strides_${axis}`));

	let index = range(ndim).map(axis => `i_${axis}`);
	let shape = range(ndim).map(axis => `shape_${axis}`);

	return {
		fn,
		out,
		x,
		out_offset,
		x_offset,
		out_data,
		x_data,
		out_strides,
		x_strides,
		index,
		shape,
	};
}

function declarations(obj, data, offset, strides) {
	let statements = [];

	statements.push(assignment('let', data, dotAccess(obj, 'data')));
	statements.push(assignment('let', offset, dotAccess(obj, 'offset')));
	if (strides.length > 0)
		statements.push(
			destructuringObject('let', strides, dotAccess(obj, 'strides'), range(strides.length))
		);

	return statements;
}

function _map_body(narg, ndim) {
	let { fn, out, x, out_offset, x_offset, out_data, x_data, out_strides, x_strides, index, shape } =
		variableNames(narg, ndim);

	let statements = [];

	statements.push(...declarations(out, out_data, out_offset, out_strides));

	x.forEach((x, i) => {
		statements.push(...declarations(x, x_data[i], x_offset[i], x_strides[i]));
	});

	statements.push(destructuringObject('let', shape, dotAccess(x[0], 'shape'), range(shape.length)));

	statements.push(
		range(ndim)
			.reverse()
			.reduce(
				(body, axis) => forLoop(index[axis], shape[axis], body),
				body(
					assignment(
						null,
						[
							bracketAccess(
								out_data,
								sum(
									out_offset,
									...index.map((index, axis) => product(index, out_strides[axis]))
								)
							),
						],
						[
							functionCall(
								fn,
								...x_data.map((x_data, i) =>
									bracketAccess(
										x_data,
										sum(
											x_offset[i],
											...index.map((index, axis) => product(index, x_strides[i][axis]))
										)
									)
								)
							),
						]
					)
				)
			),
		functionReturn(out)
	);

	return [fn, ...x, out, body(...statements)];
}

function _outer_body(narg, ndim) {}

function _reduce_body(narg, ndim, axis) {
	// axis as bool(0, 1) mask

	let out_ndim = ndim;
	for (let i = 0; i &lt; ndim; i++) out_ndim -= axis[i];

	let { fn, out, x, out_offset, x_offset, out_data, x_data, out_strides, x_strides, index, shape } =
		variableNames(narg, ndim, out_ndim);

	let initial = 'initial';
	let accum = 'accum';
	let x_start = x.map(x => `${x}_start`);

	let statements = [];

	statements.push(...declarations(out, out_data, out_offset, out_strides));

	x.forEach((x, i) => {
		statements.push(...declarations(x, x_data[i], x_offset[i], x_strides[i]));
	});

	statements.push(destructuringObject('let', shape, dotAccess(x[0], 'shape'), range(shape.length)));

	statements.push(
		range(ndim)
			.filter(i => !axis[i])
			.reverse()
			.reduce(
				(body, axis) => forLoop(index[axis], shape[axis], body),
				body(
					assignment('let', accum, initial),
					...x_start.map((x_start, i) =>
						assignment(
							'let',
							x_start,
							sum(
								x_offset[i],
								...range(ndim)
									.filter(i => !axis[i])
									.map(axis => product(index[axis], x_strides[i][axis]))
							)
						)
					),
					range(ndim)
						.filter(i => axis[i])
						.reverse()
						.reduce(
							(body, axis) => forLoop(index[axis], shape[axis], body),
							body([
								assignment(
									null,
									accum,
									functionCall(
										fn,
										accum,
										...x_data.map((x_data, i) =>
											bracketAccess(
												x_data,
												sum(
													x_start[i],
													...range(ndim)
														.filter(i => axis[i])
														.map(axis => product(index[axis], x_strides[i][axis]))
												)
											)
										)
									)
								),
							])
						),
					assignment(
						null,
						bracketAccess(
							out_data,
							sum(
								out_offset,
								...range(ndim)
									.filter(i => !axis[i])
									.map((axis, i) => product(index[axis], out_strides[i]))
							)
						),
						accum
					)
				)
			),
		functionReturn(out)
	);

	return [fn, ...x, out, initial, body(...statements)];
}

function _accumulate_body(narg, ndim, axis) {
	let out_ndim = ndim;

	let { fn, out, x, out_offset, x_offset, out_data, x_data, out_strides, x_strides, index, shape } =
		variableNames(narg, ndim, out_ndim);

	let initial = 'initial';
	let accum = 'accum';
	let x_start = x.map(x => `${x}_start`);
	let offset_start = `offset_start`;

	let statements = [];

	statements.push(...declarations(out, out_data, out_offset, out_strides));

	x.forEach((x, i) => {
		statements.push(...declarations(x, x_data[i], x_offset[i], x_strides[i]));
	});

	statements.push(destructuringObject('let', shape, dotAccess(x[0], 'shape'), range(shape.length)));

	statements.push(
		range(ndim)
			.filter(i => !axis[i])
			.reverse()
			.reduce(
				(body, axis) => forLoop(index[axis], shape[axis], body),
				body(
					assignment('let', accum, initial),
					...x_start.map((x_start, i) =>
						assignment(
							'let',
							x_start,
							sum(
								x_offset[i],
								...range(ndim)
									.filter(i => !axis[i])
									.map(axis => product(index[axis], x_strides[i][axis]))
							)
						)
					),
					assignment(
						'let',
						offset_start,
						sum(
							out_offset,
							...range(ndim)
								.filter(i => !axis[i])
								.map(axis => product(index[axis], out_strides[axis]))
						)
					),
					range(ndim)
						.filter(i => axis[i])
						.reverse()
						.reduce(
							(body, axis) => forLoop(index[axis], shape[axis], body),
							body([
								assignment(
									null,
									accum,
									functionCall(
										fn,
										accum,
										...x_data.map((x_data, i) =>
											bracketAccess(
												x_data,
												sum(
													x_start[i],
													...range(ndim)
														.filter(i => axis[i])
														.map(axis => product(index[axis], x_strides[i][axis]))
												)
											)
										)
									)
								),
								assignment(
									null,
									bracketAccess(
										out_data,
										sum(
											offset_start,
											...range(ndim)
												.filter(i => axis[i])
												.map((axis, i) => product(index[axis], out_strides[axis]))
										)
									),
									accum
								),
							])
						)
				)
			),
		functionReturn(out)
	);

	return [fn, ...x, out, initial, body(...statements)];
}

let _map = _cache((narg, ndim) => {
	return new Function(..._map_body(narg, ndim));
});

let _outer = _cache((narg, ndims) => {
	return new Function();
});

let _reduce = _cache((narg, ndim, axis) => {
	return new Function(..._reduce_body(narg, ndim, axis));
});

let _accumulate = _cache((narg, ndim, axis) => {
	return new Function(..._accumulate_body(narg, ndim, axis));
});

export function _wrap_map(name, fn, narg = fn.length, use_args = false) {
	let func;
	if (narg == 1) {
		if (use_args) {
			func = (x1, out = null, args = null) => {
				x1 = asarray(x1);
				if (out == null) {
					out = empty(x1.shape);
				} else {
					x1 = broadcast_to(x1, out.shape);
				}
				return _map(1, out.ndim)(fn.bind(null, args), x1, out);
			};
		} else {
			func = (x1, out = null) => {
				x1 = asarray(x1);
				if (out == null) {
					out = empty(x1.shape);
				} else {
					x1 = broadcast_to(x1, out.shape);
				}
				return _map(1, out.ndim)(fn, x1, out);
			};
		}
	} else if (narg == 2) {
		func = (x1, x2, out = null) => {
			x1 = asarray(x1);
			x2 = asarray(x2);
			let shape;
			if (out == null) {
				shape = broadcast_shapes(x1.shape, x2.shape);
				out = empty(shape);
			} else shape = out.shape;
			x1 = broadcast_to(x1, shape);
			x2 = broadcast_to(x2, shape);
			return _map(2, out.ndim)(fn, x1, x2, out);
		};
	} else throw 'not support on narg > 2 yet';
	return Object.defineProperty(func, 'name', { value: name });
}

export function _wrap_map_unary(name, fn, use_args = false) {
	if (use_args) {
		/**
		 *
		 * @param {NDArray} x1
		 * @param {NDArray} out
		 * @param {{}} args
		 * @returns {NDArray}
		 */
		function func(x1, out = null, args = null) {
			x1 = asarray(x1);
			if (out == null) {
				out = empty(x1.shape);
			} else {
				x1 = broadcast_to(x1, out.shape);
			}
			return _map(1, out.ndim)(fn.bind(null, args), x1, out);
		}
		return Object.defineProperty(func, 'name', { value: name });
	}
	/**
	 *
	 * @param {NDArray} x1
	 * @param {NDArray} out
	 * @returns {NDArray}
	 */
	function func(x1, out = null) {
		x1 = asarray(x1);
		if (out == null) {
			out = empty(x1.shape);
		} else {
			x1 = broadcast_to(x1, out.shape);
		}
		return _map(1, out.ndim)(fn, x1, out);
	}
	return Object.defineProperty(func, 'name', { value: name });
}

/**
 * @param {string} name
 * @param {function(any, any): any} fn
 * @ignore
 */
export function _wrap_map_binary(name, fn) {
	/**
	 * @param {NDArray} x1
	 * @param {NDArray} x2
	 * @param {NDArray} [out]
	 * @returns {NDArray}
	 */
	function func(x1, x2, out = null) {
		x1 = asarray(x1);
		x2 = asarray(x2);
		let shape;
		if (out == null) {
			shape = broadcast_shapes(x1.shape, x2.shape);
			out = empty(shape);
		} else shape = out.shape;
		x1 = broadcast_to(x1, shape);
		x2 = broadcast_to(x2, shape);
		return _map(2, out.ndim)(fn, x1, x2, out);
	}

	return Object.defineProperty(func, 'name', { value: name });
}

export function _wrap_accum_unary(name, fn, defaultinitial) {
	/**
	 *
	 * @param {ArrayLike} x1
	 * @param {number} [axis]
	 * @param {NDArray} [out]
	 * @param {any} [initial]
	 * @returns {NDArray}
	 */
	function func(x1, axis = null, out = null, initial = defaultinitial) {
		x1 = asarray(x1);
		if (axis == null) {
			x1 = ravel(x1);
		}
		let { ndim, shape } = x1;
		axis = normalize_axis_mask(axis, ndim);
		if (out == null) out = empty(shape);
		else if (!shallow_array_equal(shape, out.shape)) throw 'unmatch shape';

		_accumulate(1, ndim, axis)(fn, x1, out, initial);
		return out;
	}
	return Object.defineProperty(func, 'name', { value: name });
}

const EMPTY_SHAPE = [];

export function _wrap_reduce(name, fn, narg = fn.length - 1, defaultinitial) {
	if (narg != 1) throw 'not support on narg > 1 yet';
	/**
	 *
	 * @param {NDArray} x1
	 * @param {number} axis
	 * @param {NDArray} out
	 * @param {boolean} keepdims
	 * @param {any} initial
	 * @param {boolean} return_scalar
	 * @returns {NDArray}
	 */
	function func(
		x1,
		axis = null,
		out = null,
		keepdims = false,
		initial = defaultinitial,
		return_scalar = true
	) {
		if (out != null) return_scalar = false;
		x1 = asarray(x1);
		let { ndim, shape } = x1;
		let outshape;
		if (axis == null) {
			axis = normalize_axis_mask(axis, ndim);
			outshape = EMPTY_SHAPE;
		} else {
			axis = normalize_axis_mask(axis, ndim);
			outshape = [];
			for (let i = 0; i &lt; ndim; i++) if (!axis[i]) outshape.push(shape[i]);
		}
		if (keepdims) {
			// very hacky
			// kinda force it to keepdims=false
			// and force it back to original shape and strides (ndim is not used in the loop)

			// maybe pass out_data, out_strides, out_shape instead of out to the generated function
			// to avoid this?

			// let { strides } = x1;
			let sameshape = shape.slice();
			// let outstrides = [];
			for (let i = 0; i &lt; ndim; i++) {
				if (axis[i]) {
					sameshape[i] = 1;
				} else {
					// outstrides.push(strides[i]);
				}
			}
			if (out == null) out = empty(sameshape);
			else if (!shallow_array_equal(sameshape, out.shape)) throw 'unmatch shape';
			// else {
			// 	sameshape = out.shape;
			// 	strides = out.strides;
			// }

			// out.shape = outshape;
			// out.strides = outstrides;

			// out = _reduce(1, ndim, axis)(fn, x1, out, initial);

			// out.shape = sameshape;
			// out.strides = strides;

			// how about reshape out as a non-copy view?
			// if only interleaved 1s exist in the shape
			// seems working
			_reduce(1, ndim, axis)(fn, x1, out.reshape(outshape), initial);
			return return_scalar &amp;&amp; out.ndim == 0 ? out.item() : out;
		}

		if (out == null) out = empty(outshape);
		else if (!shallow_array_equal(outshape, out.shape)) throw 'unmatch shape';

		out = _reduce(1, ndim, axis)(fn, x1, out, initial);
		return return_scalar &amp;&amp; out.ndim == 0 ? out.item() : out;
	}
	return Object.defineProperty(func, 'name', { value: name });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Broadcast.html">Broadcast</a></li><li><a href="Dtype.html">Dtype</a></li><li><a href="Flatiter.html">Flatiter</a></li><li><a href="Generator.html">Generator</a></li><li><a href="NDArray.html">NDArray</a></li><li><a href="Nditer.html">Nditer</a></li><li><a href="Ndoffset.html">Ndoffset</a></li><li><a href="Slice.html">Slice</a></li><li><a href="SliceIterator.html">SliceIterator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#NINF">NINF</a></li><li><a href="global.html#abs">abs</a></li><li><a href="global.html#add">add</a></li><li><a href="global.html#all">all</a></li><li><a href="global.html#amax">amax</a></li><li><a href="global.html#amin">amin</a></li><li><a href="global.html#any">any</a></li><li><a href="global.html#arange">arange</a></li><li><a href="global.html#arccos">arccos</a></li><li><a href="global.html#arccosh">arccosh</a></li><li><a href="global.html#arcsin">arcsin</a></li><li><a href="global.html#arcsinh">arcsinh</a></li><li><a href="global.html#arctan">arctan</a></li><li><a href="global.html#arctan2">arctan2</a></li><li><a href="global.html#arctanh">arctanh</a></li><li><a href="global.html#argsort">argsort</a></li><li><a href="global.html#argwhere">argwhere</a></li><li><a href="global.html#around">around</a></li><li><a href="global.html#array">array</a></li><li><a href="global.html#array2string">array2string</a></li><li><a href="global.html#array_equal">array_equal</a></li><li><a href="global.html#array_equiv">array_equiv</a></li><li><a href="global.html#array_repr">array_repr</a></li><li><a href="global.html#array_split">array_split</a></li><li><a href="global.html#array_str">array_str</a></li><li><a href="global.html#asarray">asarray</a></li><li><a href="global.html#ascontiguousarray">ascontiguousarray</a></li><li><a href="global.html#atleast_1d">atleast_1d</a></li><li><a href="global.html#atleast_2d">atleast_2d</a></li><li><a href="global.html#atleast_3d">atleast_3d</a></li><li><a href="global.html#average">average</a></li><li><a href="global.html#bincount">bincount</a></li><li><a href="global.html#bitwise_and">bitwise_and</a></li><li><a href="global.html#bitwise_not">bitwise_not</a></li><li><a href="global.html#bitwise_or">bitwise_or</a></li><li><a href="global.html#bitwise_xor">bitwise_xor</a></li><li><a href="global.html#broadcast">broadcast</a></li><li><a href="global.html#broadcast_shapes">broadcast_shapes</a></li><li><a href="global.html#broadcast_to">broadcast_to</a></li><li><a href="global.html#cbrt">cbrt</a></li><li><a href="global.html#ceil">ceil</a></li><li><a href="global.html#clip">clip</a></li><li><a href="global.html#column_stack">column_stack</a></li><li><a href="global.html#compress">compress</a></li><li><a href="global.html#concatenate">concatenate</a></li><li><a href="global.html#convolve">convolve</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#copysign">copysign</a></li><li><a href="global.html#copyto">copyto</a></li><li><a href="global.html#cos">cos</a></li><li><a href="global.html#cosh">cosh</a></li><li><a href="global.html#count_nonzero">count_nonzero</a></li><li><a href="global.html#cross">cross</a></li><li><a href="global.html#cumprod">cumprod</a></li><li><a href="global.html#cumsum">cumsum</a></li><li><a href="global.html#deg2rad">deg2rad</a></li><li><a href="global.html#degrees">degrees</a></li><li><a href="global.html#diag">diag</a></li><li><a href="global.html#diagonal">diagonal</a></li><li><a href="global.html#diff">diff</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#dot">dot</a></li><li><a href="global.html#dstack">dstack</a></li><li><a href="global.html#dtype">dtype</a></li><li><a href="global.html#e">e</a></li><li><a href="global.html#ediff1d">ediff1d</a></li><li><a href="global.html#empty">empty</a></li><li><a href="global.html#empty_like">empty_like</a></li><li><a href="global.html#equal">equal</a></li><li><a href="global.html#exp">exp</a></li><li><a href="global.html#exp2">exp2</a></li><li><a href="global.html#expand_dims">expand_dims</a></li><li><a href="global.html#expm1">expm1</a></li><li><a href="global.html#extract">extract</a></li><li><a href="global.html#eye">eye</a></li><li><a href="global.html#fix">fix</a></li><li><a href="global.html#flatnonzero">flatnonzero</a></li><li><a href="global.html#flip">flip</a></li><li><a href="global.html#fliplr">fliplr</a></li><li><a href="global.html#flipud">flipud</a></li><li><a href="global.html#floor">floor</a></li><li><a href="global.html#floor_divide">floor_divide</a></li><li><a href="global.html#fmod">fmod</a></li><li><a href="global.html#fromfunction">fromfunction</a></li><li><a href="global.html#fromiter">fromiter</a></li><li><a href="global.html#full">full</a></li><li><a href="global.html#full_like">full_like</a></li><li><a href="global.html#gcd">gcd</a></li><li><a href="global.html#greater">greater</a></li><li><a href="global.html#greater_equal">greater_equal</a></li><li><a href="global.html#hstack">hstack</a></li><li><a href="global.html#hypot">hypot</a></li><li><a href="global.html#identity">identity</a></li><li><a href="global.html#index_exp">index_exp</a></li><li><a href="global.html#indices">indices</a></li><li><a href="global.html#inf">inf</a></li><li><a href="global.html#interp">interp</a></li><li><a href="global.html#invert">invert</a></li><li><a href="global.html#isfinite">isfinite</a></li><li><a href="global.html#isinf">isinf</a></li><li><a href="global.html#isna">isna</a></li><li><a href="global.html#isneginf">isneginf</a></li><li><a href="global.html#isposinf">isposinf</a></li><li><a href="global.html#isscalar">isscalar</a></li><li><a href="global.html#ix_">ix_</a></li><li><a href="global.html#lcm">lcm</a></li><li><a href="global.html#ldexp">ldexp</a></li><li><a href="global.html#left_shift">left_shift</a></li><li><a href="global.html#less">less</a></li><li><a href="global.html#less_equal">less_equal</a></li><li><a href="global.html#linspace">linspace</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#log10">log10</a></li><li><a href="global.html#log1p">log1p</a></li><li><a href="global.html#log2">log2</a></li><li><a href="global.html#logaddexp">logaddexp</a></li><li><a href="global.html#logaddexp2">logaddexp2</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#matmul">matmul</a></li><li><a href="global.html#maximum">maximum</a></li><li><a href="global.html#mean">mean</a></li><li><a href="global.html#minimum">minimum</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#moveaxis">moveaxis</a></li><li><a href="global.html#multiply">multiply</a></li><li><a href="global.html#nan">nan</a></li><li><a href="global.html#nan_to_num">nan_to_num</a></li><li><a href="global.html#nanprod">nanprod</a></li><li><a href="global.html#nansum">nansum</a></li><li><a href="global.html#ndenumerate">ndenumerate</a></li><li><a href="global.html#ndim">ndim</a></li><li><a href="global.html#ndindex">ndindex</a></li><li><a href="global.html#nditer">nditer</a></li><li><a href="global.html#ndoffset">ndoffset</a></li><li><a href="global.html#negative">negative</a></li><li><a href="global.html#nonzero">nonzero</a></li><li><a href="global.html#not_equal">not_equal</a></li><li><a href="global.html#ogrid">ogrid</a></li><li><a href="global.html#ones">ones</a></li><li><a href="global.html#ones_like">ones_like</a></li><li><a href="global.html#packbits">packbits</a></li><li><a href="global.html#pi">pi</a></li><li><a href="global.html#pick">pick</a></li><li><a href="global.html#positive">positive</a></li><li><a href="global.html#power">power</a></li><li><a href="global.html#prod">prod</a></li><li><a href="global.html#ptp">ptp</a></li><li><a href="global.html#put">put</a></li><li><a href="global.html#rad2deg">rad2deg</a></li><li><a href="global.html#radians">radians</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#ravel">ravel</a></li><li><a href="global.html#ravel_multi_index">ravel_multi_index</a></li><li><a href="global.html#remainder">remainder</a></li><li><a href="global.html#repeat">repeat</a></li><li><a href="global.html#reshape">reshape</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#right_shift">right_shift</a></li><li><a href="global.html#rint">rint</a></li><li><a href="global.html#roll">roll</a></li><li><a href="global.html#row_stack">row_stack</a></li><li><a href="global.html#s_">s_</a></li><li><a href="global.html#searchsorted">searchsorted</a></li><li><a href="global.html#shape">shape</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#signbit">signbit</a></li><li><a href="global.html#sin">sin</a></li><li><a href="global.html#sinh">sinh</a></li><li><a href="global.html#slice">slice</a></li><li><a href="global.html#sort">sort</a></li><li><a href="global.html#split">split</a></li><li><a href="global.html#sqrt">sqrt</a></li><li><a href="global.html#square">square</a></li><li><a href="global.html#squeeze">squeeze</a></li><li><a href="global.html#stack">stack</a></li><li><a href="global.html#std">std</a></li><li><a href="global.html#subtract">subtract</a></li><li><a href="global.html#sum">sum</a></li><li><a href="global.html#swapaxes">swapaxes</a></li><li><a href="global.html#take">take</a></li><li><a href="global.html#tan">tan</a></li><li><a href="global.html#tanh">tanh</a></li><li><a href="global.html#tile">tile</a></li><li><a href="global.html#transpose">transpose</a></li><li><a href="global.html#trapz">trapz</a></li><li><a href="global.html#true_divide">true_divide</a></li><li><a href="global.html#trunc">trunc</a></li><li><a href="global.html#unpackbits">unpackbits</a></li><li><a href="global.html#unravel_index">unravel_index</a></li><li><a href="global.html#unwrap">unwrap</a></li><li><a href="global.html#variance">variance</a></li><li><a href="global.html#vstack">vstack</a></li><li><a href="global.html#where">where</a></li><li><a href="global.html#zeros">zeros</a></li><li><a href="global.html#zeros_like">zeros_like</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Apr 25 2023 17:10:41 GMT+0800 (Hong Kong Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
